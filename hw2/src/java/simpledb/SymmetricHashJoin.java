package simpledb;

import java.util.*;

/**
 * The SymmetricHashJoin operator implements the symmetric hash join operation.
 */
public class SymmetricHashJoin extends Operator {
    private JoinPredicate pred;
    private DbIterator child1, child2;
    private TupleDesc comboTD;

    private HashMap<Object, ArrayList<Tuple>> leftMap = new HashMap<Object, ArrayList<Tuple>>();
    private HashMap<Object, ArrayList<Tuple>> rightMap = new HashMap<Object, ArrayList<Tuple>>();

    private ArrayList<Tuple> outputlist = new ArrayList<Tuple>();
    private boolean switced = true;

     /**
     * Constructor. Accepts children to join and the predicate to join them on.
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public SymmetricHashJoin(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.pred = p;
        this.child1 = child1;
        this.child2 = child2;
        comboTD = TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc());
    }

    public TupleDesc getTupleDesc() {
        return comboTD;
    }

    /**
     * Opens the iterator.
     */
    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        // IMPLEMENT ME
        child1.open();
        child2.open();
        super.open();
    }

    /**
     * Closes the iterator.
     */
    public void close() {
        // IMPLEMENT ME
        super.close();
        child2.close();
        child1.close();
    }

    /**
     * Rewinds the iterator. You should not be calling this method for this join. 
     */
    public void rewind() throws DbException, TransactionAbortedException {
        child1.rewind();
        child2.rewind();
        this.leftMap.clear();
        this.rightMap.clear();
    }

    /**
     * Fetches the next tuple generated by the join, or null if there are no 
     * more tuples.  Logically, this is the next tuple in r1 cross r2 that
     * satifies the join predicate.
     *
     * Note that the tuples returned from this particular implementation are
     * simply the concatenation of joining tuples from the left and right
     * relation.  Therefore, there will be two copies of the join attribute in
     * the results.
     *
     * For example, joining {1,2,3} on equality of the first column with {1,5,6}
     * will return {1,2,3,1,5,6}.
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        // IMPLEMENT ME

        int field1 = pred.getField1();
        int field2 = pred.getField2();
        if (!outputlist.isEmpty()) {
            Tuple output = outputlist.get(0);
            outputlist.remove(0);
            return output;
        }
        switchRelations();
        while (child1.hasNext() || child2.hasNext()) {
            if  (!switced && child1.hasNext()) {
                Tuple t1 = child1.next();
                int key1 = t1.getField(field1).hashCode();
                ArrayList<Tuple> list1;
                if (!leftMap.containsKey(key1)) {
                    list1 = new ArrayList<Tuple>();
                } else {
                    list1 = leftMap.get(key1);
                }
                list1.add(t1);
                leftMap.put(key1, list1);

                 ArrayList<Tuple> list2 = rightMap.get(key1);
                 if (list2 != null) {
                    for (Tuple t2 : list2) {

                        int td1n = t1.getTupleDesc().numFields();
                        int td2n = t2.getTupleDesc().numFields();

                        Tuple t = new Tuple(comboTD);
                        for (int i = 0; i < td1n; i++)
                            t.setField(i, t1.getField(i));
                        for (int i = 0; i < td2n; i++)
                            t.setField(td1n + i, t2.getField(i));

                        outputlist.add(t);
                    }    
                    Tuple output = outputlist.get(0);
                    outputlist.remove(0);
                    return output;
                } else {
                    switchRelations();
                }
            }

            if  (switced && child2.hasNext()) {
                Tuple t2 = child2.next();
                int key2 = t2.getField(field2).hashCode();
                ArrayList<Tuple> list2;
                if (!rightMap.containsKey(key2)) {
                    list2 = new ArrayList<Tuple>();
                } else {
                    list2 = rightMap.get(key2);
                }
                list2.add(t2);
                rightMap.put(key2, list2);

                 ArrayList<Tuple> list1 = leftMap.get(key2);
                 if (list1 != null) {
                    for (Tuple t1 : list1) {

                        int td1n = t1.getTupleDesc().numFields();
                        int td2n = t2.getTupleDesc().numFields();

                        Tuple t = new Tuple(comboTD);
                        for (int i = 0; i < td1n; i++)
                            t.setField(i, t1.getField(i));
                        for (int i = 0; i < td2n; i++)
                            t.setField(td1n + i, t2.getField(i));
                        outputlist.add(t);
                    }    
                    Tuple output = outputlist.get(0);
                    outputlist.remove(0);
                    return output;
                } else {
                    switchRelations();
                }
            }
        }
        return null;
    }

    /**
     * Switches the inner and outer relation.
     */
    private void switchRelations() throws TransactionAbortedException, DbException {
        // IMPLEMENT ME
        if (switced && child1.hasNext()) {
            switced = false;
        } 

        if (!switced && child2.hasNext()) {
            switced = true;
        }
    }

    @Override
    public DbIterator[] getChildren() {
        return new DbIterator[]{this.child1, this.child2};
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.child1 = children[0];
        this.child2 = children[1];
    }

}